
<!--
TODO: make this into an element visingo-visualizer-content-visjs that can
be extended by the visualizer package (often empty extension, but less repeated code?)

TODO: import System.js

TODO: make own bower.json for each visualizer?

TODO: remove visjsConfigurator
-->

<!-- import vis.js (global vis)-->
<link rel="import" href="../../elements/vis-import.html">
<!-- import lodash (global _) -->
<link rel="import" href="../../elements/lodash-import.html">
<!-- import tock (global class Tock) -->
<link rel="import" href="../../elements/tock-import.html">
<!-- import parser -->
<link rel="import" href="../../elements/visingo-parsers/answersetterms-to-visjs.html">

<link rel="import" href="toolbar-controls.html">

<dom-module id="visualizer-test-vis-graph-element">
  <template>

    <style type="text/css">
      :host {
        /*display: block;
        position: relative;*/
        display: block;
        width: 100%;
        height: 100%;
      }
      #visjsCanvasContainer {
        width: 100%;
        height: 100%;
        background-color: #fff;
      }
      #visjsConfigurator {
        display: hidden;
      }
    </style>

    <!-- vis.js canvas div -->
    <div id="visjsCanvasContainer"></div>
    <div id="visjsConfigurator"></div>


  </template>
</dom-module>
<script>
  (function() {
    Polymer({
      is: 'visualizer-test-vis-graph-element',

      properties: {
        input: {
          type: Object
        },
        _visScript: {
          type: Object,
          readonly: true
        },
        _timer: {
          type: Object,
          readonly: true
        },
        _timerInterval: {
          type: Number,
          value: 8000 // milliseconds
        },
        _playbackState: {
          type: Object,
          value: function() { return {}; }
        },
        _toolbarControlsElement: {
          type: Object
        }
      },

      _ctlPlay: function() {
        console.log('controls: play');
        // if already playing
        if(this._timer.go) return;
        // if paused, call pause to resume
        if(this._timer.pause_time) { return this._timer.pause(); }
        // otherwise start playing if we are not in the end
        if(this._playbackState.pointer < this._playbackState.data.length - 1)
          this.playbackTick();
      },

      _ctlPause: function() {
        console.log('controls: pause');
        this._timer.pause();
      },

      _ctlNext: function() {
        console.log('controls: next');
        if(this._timer.go) { // NOTE: timer shouldn't be on if pointer is at end
          this._timer.stop();
          this._timer.reset();
          this.playbackTick.bind(this)(); // TODO: is bind needed?
        }
        else {
          if(this._playbackState.pointer < this._playbackState.data.length - 1)
            this.playbackNext();
        }
      },

      _ctlPrevious: function() {
        console.log('controls: previous');
        // TODO: implement
        console.log('NOTE: "previous" not implemented');
      },

      _ctlToStart: function() {
        console.log('controls: toStart');
        this._timer.stop();
        this._timer.reset();
        // rewind to start (destroy and init), but don't start automatically
        this._visScript.destroy();
        this._visScript.initialize(this.$.visjsCanvasContainer, this.input.settings);
        this._playbackState.pointer = 0;
      },

      _ctlToEnd: function() {
        console.log('controls: toEnd');
        this._timer.stop();
        this._timer.reset();

        var len = this._playbackState.data.length;
        var cur = this._playbackState.pointer;
        // queue the rest of the sets
        for(var i = cur; i < len-cur; i++) {
          this._visScript.queueAnswerSet(
              this._playbackState.data[i].Value
          );
        }
        this._playbackState.pointer = len-1;
        this._visScript.flushChanges();
      },

      created: function() {
        // load visualizer script
        System.import(this.resolveUrl('visualizer.js')).then(function(m) {
          this._visScript = m;
        }.bind(this));
      },

      attached: function() {
        // attach controls to the toolbar
        //this.async(function() {
          var elem = document.createElement(
            'visualizer-test-vis-graph-toolbar-controls'
          );

          elem.controls = {
            play: function() { return this._ctlPlay(); }.bind(this),
            pause: function() { return this._ctlPause(); }.bind(this),
            next: function() { return this._ctlNext(); }.bind(this),
            previous: function() { return this._ctlPrevious(); }.bind(this),
            toStart: function() { return this._ctlToStart(); }.bind(this),
            toEnd: function() { return this._ctlToEnd(); }.bind(this),
          };

          // TODO: When imperative javascript two-way binding for Polymer is
          //       again available (removed in 1.0), change this to a binding.
          //       Current solution is admittedly an ugly hack.
          elem.updateInterval = {f: function(value, old) {
            this._timerInterval = value;
          }.bind(this)};

          var tb = document.getElementById('visingoMainToolbar');
          tb.attachComponent(elem);
          this._toolbarControlsElement = elem;
        //});
        this.waitForLoad();
      },

      waitForLoad: function() {
        this.async(function() {
          // wait until _visScript is loaded
          if(typeof this._visScript === 'undefined') {
            this.waitLoad();
            console.log('Waiting for _visScript...');
            return;
          }

          this.launch();
        }, 48); // 48/16 ~ 3 frames
      },

      launch: function() {
        this._visScript.initialize(this.$.visjsCanvasContainer, this.input.settings);
        // TODO: remove window.vs which is here for development convenience
        window.vs = this._visScript;

        window.visingo = window.visingo || {};
        window.visingo.debug = window.visingo.debug || {};
        window.visingo.debug.script = this._visScript;
        window.visingo.debug.element = this;
        window.visingo.debug.container = this.$.visjsCanvasContainer;

        if(this.input.visualizationType === 'playback')
          this.startPlayback();
      },

      startPlayback: function () {
        this._timer = new Tock({
          countdown: true,
          interval: 16, // 16ms ~ 60fps
          callback: this.timerTick.bind(this),
          complete: this.playbackTick.bind(this)
        });
        console.log(this.input);
        // TODO take into account multiple solve calls
        this._playbackState.data = this.input.inputFiles[0].data.Call[0].Witnesses;
        this._playbackState.pointer = 0;
        console.log(this._playbackState.data);

        // if no anwer sets are present
        if(typeof this._playbackState.data[this._playbackState.pointer] === 'undefined')
          return;

        // load first answer set immediately
        this.playbackTick.bind(this)(); // TODO: is bind needed?
      },

      playbackTick: function() {
        if(this.playbackNext()) {
          this._timer.reset();
          this._timer.start(this._timerInterval);
        }
      },

      // returns boolean, whether caller can continue timer or not
      playbackNext: function() {
        this._visScript.addAnswerSet(
            this._playbackState.data[this._playbackState.pointer].Value
        );

        // flash time display
        this._toolbarControlsElement.$.timeToNextInputContainer._setFocused(true);
        this.async(function() {
          this._toolbarControlsElement.$.timeToNextInputContainer._setFocused(false);
        }, 250); // 250ms seems to be enough for the underline to flash fully

        // if in the end TODO: make based on length?
        if(typeof this._playbackState.data[this._playbackState.pointer + 1] === 'undefined')
          return false;

        this._playbackState.pointer = this._playbackState.pointer + 1;

        return true;
      },

      timerTick: function() {
        // update time display
        this._toolbarControlsElement.timeToNext = this._timer.msToTime(this._timer.lap());
      }

    });
  })();
</script>


<!--
TODO: make this into an element visingo-visualizer-content-visjs that can
be extended by the visualizer package (often empty extension, but less repeated code?)

TODO: make own bower.json for each visualizer?

TODO: additional settings dialog, follow node network.focus(NodeID, {scale: 0.5, animation: true, locked: true})
-->

<!-- import system.js (global System.import()) -->
<link rel="import" href="../../elements/systemjs-import.html">
<!-- import vis.js (global vis)-->
<link rel="import" href="../../elements/vis-import.html">
<!-- import lodash (global _) -->
<link rel="import" href="../../elements/lodash-import.html">
<!-- import tock (global class Tock) -->
<link rel="import" href="../../elements/tock-import.html">
<!-- import parser, required for visualization.js -->
<link rel="import" href="../../elements/visingo-parsers/answersetterms-to-visjs.html">

<link rel="import" href="toolbar-controls.html">

<dom-module id="visualizer-test-vis-graph-element">
  <template>

    <style type="text/css">
      :host {
        /*display: block;
        position: relative;*/
        display: block;
        width: 100%;
        height: 100%;
      }
      #visjsCanvasContainer {
        width: 100%;
        height: 100%;
        background-color: #fff;
      }
      #visjsConfigurator {
        display: hidden;
      }
    </style>

    <!-- vis.js canvas div -->
    <div id="visjsCanvasContainer"></div>

  </template>
</dom-module>
<script>
  (function() {
    var MIN_ZOOM_INTERVAL = 2000; // ms

    Polymer({
      is: 'visualizer-test-vis-graph-element',

      properties: {
        input: {
          type: Object
        },
        _visScript: {
          type: Object,
          readonly: true
        },
        _timer: {
          type: Object,
          readonly: true
        },
        _timerInterval: {
          type: Number,
          value: 8000 // milliseconds
        },
        _playbackState: {
          type: Object,
          value: function() { return {}; }
        },
        _toolbarControlsElement: {
          type: Object
        },
        _autoZoom: {
          type: Boolean,
          value: false,
          observer: '_autoZoomChanged'
        },
      },

      observers: [
        '_playbackPointerChanged(_playbackState.current)'
      ],

      _playbackPointerChanged: function(state) {
        // bind playback pointer to answer number in toolbar
        if(typeof this._toolbarControlsElement === 'undefined') return;
        this._toolbarControlsElement.set('answerNumber', state);
        // auto zoom
        if(this._autoZoom === true) {
          this._fitLater();
        }
      },

      _autoZoomChanged: function(newVal, oldVal) {
        if(newVal === false) return;
        // Do fit later:
        this._fitLater();
      },

      // NOTE: Try to avoid two network fit animations being in action at the same time.
      _fitLater: function() {
        // NOTE: minimum animation time will be 1000ms, if we don't have that
        // much time, just skip the fit.
        if(this._timerInterval < MIN_ZOOM_INTERVAL) return;

        var maxTimeForAnimation = this._timerInterval - 1000;
        // cap at 3000
        maxTimeForAnimation = (maxTimeForAnimation > 3000) ? 3000 : maxTimeForAnimation;

        this.async(function() {
          this.fitNetwork(maxTimeForAnimation);
        }.bind(this), 1000);
      },

      fitNetwork: function() {
        this._visScript.fitNetwork();
      },

      _ctlPlay: function() {
        console.log('controls: play');
        // if already playing
        if(this._timer.go) return;
        // if paused, call pause to resume
        if(this._timer.pause_time) { return this._timer.pause(); }
        // otherwise start playing if we are not in the end
        if(this._playbackState.current < this._playbackState.data.length - 1)
          this.playbackTick();
      },

      _ctlPause: function() {
        console.log('controls: pause');
        this._timer.pause();
      },

      _ctlNext: function() {
        console.log('controls: next');
        if(this._timer.go) { // NOTE: timer shouldn't be on if pointer is at end
          this._timer.stop();
          this._timer.reset();
          this.playbackTick.bind(this)(); // TODO: is bind needed?
        }
        else {
          if(this._playbackState.current < this._playbackState.data.length - 1)
            this.playbackNext();
        }
      },

      _ctlPrevious: function() {
        console.log('controls: previous');
        // TODO: implement
        console.log('NOTE: "previous" not implemented');
      },

      _ctlToStart: function() {
        console.log('controls: toStart');
        this._timer.stop();
        this._timer.reset();
        // rewind to start (destroy and init), but don't start automatically
        this._visScript.destroy();
        this._visScript.initialize(this.$.visjsCanvasContainer, this.input.settings);
        this.set('_playbackState.current', 0);
      },

      _ctlToEnd: function() {
        console.log('controls: toEnd');
        this._timer.stop();
        this._timer.reset();

        var len = this._playbackState.data.length;
        var cur = this._playbackState.current;
        // queue the rest of the sets
        for(var i = cur; i < len-cur; i++) {
          this._visScript.queueAnswerSet(
              this._playbackState.data[i].Value
          );
        }
        this.set('_playbackState.current', len-1);
        this._visScript.flushChanges();
      },

      created: function() {
        // load visualizer script
        System.import(this.resolveUrl('visualizer.js')).then(function(m) {
          this._visScript = m;
        }.bind(this));
      },

      attached: function() {
        var elem = document.createElement(
          'visualizer-test-vis-graph-toolbar-controls'
        );

        elem.controls = {
          play: function() { return this._ctlPlay(); }.bind(this),
          pause: function() { return this._ctlPause(); }.bind(this),
          next: function() { return this._ctlNext(); }.bind(this),
          previous: function() { return this._ctlPrevious(); }.bind(this),
          toStart: function() { return this._ctlToStart(); }.bind(this),
          toEnd: function() { return this._ctlToEnd(); }.bind(this),
        };

        // get toolbar
        var tb = document.getElementById('visingoMainToolbar');

        // set interval default value
        elem.interval = this._timerInterval / 1000;
        // bind to interval
        elem.addEventListener('interval-changed', function(evt) {
          this._timerInterval = evt.target.interval*1000;
          if(this._timerInterval < MIN_ZOOM_INTERVAL) {
            tb.set('autoZoom', false);
            tb.set('disableAutoZoom', true);
            return;
          }
          if(tb.disableAutoZoom === true)
            tb.set('disableAutoZoom', false);
        }.bind(this));

        // attach controls to toolbar
        tb.attachComponent(elem);
        this._toolbarControlsElement = elem;
        // enable auto-zoom setting in toolbar
        tb.showAutoZoom = true;
        // bind to autozoom
        tb.addEventListener('auto-zoom-changed', function(evt) {
          this._autoZoom = evt.target.autoZoom;
        }.bind(this));

        // wait for rest of the stuff to load
        this.waitForLoad();
      },

      waitForLoad: function() {
        this.async(function() {
          // wait until _visScript is loaded
          if(typeof this._visScript === 'undefined') {
            this.waitLoad();
            console.log('Waiting for _visScript...');
            return;
          }

          this.launch();
        }, 48); // 48/16 ~ 3 frames
      },

      launch: function() {
        this._visScript.initialize(this.$.visjsCanvasContainer, this.input.settings);
        // TODO: remove window.vs which is here for development convenience
        window.vs = this._visScript;

        window.visingo = window.visingo || {};
        window.visingo.debug = window.visingo.debug || {};
        window.visingo.debug.script = this._visScript;
        window.visingo.debug.element = this;
        window.visingo.debug.container = this.$.visjsCanvasContainer;

        if(this.input.visualizationType === 'playback')
          this.startPlayback();
      },

      startPlayback: function () {
        this.set('_timer', new Tock({
          countdown: true,
          interval: 16, // 16ms ~ 60fps
          callback: this.timerTick.bind(this),
          complete: this.playbackTick.bind(this)
          })
        );
        //console.log(this.input);
        // TODO take into account multiple solve calls
        this._playbackState.data = this.input.inputFiles[0].data.Call[0].Witnesses;
        this.set('_playbackState.current', 0);
        //console.log(this._playbackState.data);

        // load first answer set immediately
        // if no anwer sets are present, playbackTick should handle it nicely
        this.playbackTick();
      },

      playbackTick: function() {
        // put first answerset to screen
        if(this.playbackNext()) {
          // then start a clock if there are more answersets
          this._timer.reset();
          this._timer.start(this._timerInterval);
        }
      },

      // displays the next answerset
      // returns boolean, whether there are more answersets to display after this one
      playbackNext: function() {
        // make sure there is a next answerset to display
        if(this._playbackState.current >= this._playbackState.data.length)
          return false;

        this._visScript.addAnswerSet(
            this._playbackState.data[this._playbackState.current].Value
        );

        // increment answerset number
        this.set('_playbackState.current', this._playbackState.current + 1);

        // flash time display focus to visually indicate change
        this._toolbarControlsElement.$.timeToNextInputContainer._setFocused(true);
        this.async(function() {
          this._toolbarControlsElement.$.timeToNextInputContainer._setFocused(false);
        }, 250); // 250ms seems to be enough for the underline to flash fully

        // if in the end TODO: make based on length?
        // if there are no more answersets to display, return false
        //if(typeof this._playbackState.data[this._playbackState.current + 1] === 'undefined')
        //  return false;
        // if there are no more answersets to display after this one, return false
        if(this._playbackState.current >= this._playbackState.data.length)
          return false;

        // there are still answersets to display, so return true
        return true;
      },

      timerTick: function() {
        // update time display
        this._toolbarControlsElement.timeToNext = this._timer.msToTime(this._timer.lap());
      }

    });
  })();
</script>

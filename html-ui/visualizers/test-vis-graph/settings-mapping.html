
<!--
TODO:
Import parser.
Strip all predicates from the json file calls. Parse all predicate names. Only accept outermost predicate, not predicates inside predicates?
Add those to a dropdown, dropdown defaults to -not chosen-.
Mark which ones are required and which ones are optional.
If there is a predicate that has a name that matches predicate we need, automatically
suggest that predicate instead of -not chosen-.
e.g. *handwave*
cycle -> args cycle([_,From,To], [_,From,To], [_,From,To]) -> edge(From,To) [dropdown-or-something]
cycle -> args cycle([_,Cost],[_,Cost],[_,Cost]) -> cost()



color(edge(N1, N2), yellow)
color(node(N1), red)
label(edge(N1, N2), "duh") or label(edge(N1, N2), 2) for costs
so cost(N1, N2, C) -> label(edge(N1, N2), C) syntax sugar

is name different than label on nodes? probably

colorGrp((N1, N2, N3, N4), yellow) colors all nodes and edges between them

cluster()
shape() // node shape

color inheritance (map html names to rgb somehow)
label bg color
label color
label size (maybe not allow, or do? affect node size)

node size

layout




NOTE: we can discard anything that is not relevant? - YES
      for debugging we just show the original unparsed predicates
      so last rule is "predicate" and we just ignore whatever it gives
      as long as it parses correctly


term
  = 




// just scratch

in the following create means create if not exists
whenever you see a node, create that node
whenever you see an edge, create the nodes involved, then create the edge
whenever you see a colorEdge, create the nodes involved, then create the edge, then add the color to it

edge: { from:node to:node }
colorNode: { node:node color:color }
colorEdge: { }



//
DECISIONS:
- INTERACTIVE MODE ALLOWS NO MAPPING, ASP PROGRAM MUST
GIVE THE TERMS REQUIRED
- MAP BOTH IDs AND STRINGS TO JS STRINGS

required form:
node(N)
edge(From, To) or edge(Id, From, To)
  - edges in form edge(From, To) will be given Id = String(From+'%'+To)
nodeAttr(N, color, Value)
edgeAttr(From, To, color, Value) or edgeAttr(Id, color, Value)

if Value is a predicate, map it to js Object {} somehow
if Value is a tuple, map it to js Array []

//

node
edge
group
layout


// end scratch


// need to get: all nodes that exist ever
// NO can't be. This would make it impossible to do interactive visualization

user gives:
node (req: N, can be multiple times): uedge(N, N, _, _)

parse rule
predicate is uedge - then add arguments[(0, 1)] to nodes
f1 = 
preds = {uedge: [f1]}
checkmatch = "uedge(" getNode "," getNode "," "," ")"
getNode = bla:(whatever node can be) { if not global.nodes[bla] then global.nodes[bla] = {} }

edge (req: From, To): uedge(From, To, _, _)
preds = {uedge: [f1, f2]}

coloring nodes (req: Node, Color): ucolor(unode(Node), Color)
preds = {uedge: ..., ucolor: [f3]}
checkmatch = "ucolor(unode"
lets assume ucolor(Color, unode(Node))
checkmatch = "ucolor(" ", unode(" "))"

coloring edges (req: From, To, Color): uedge(From, To, _, Color)
f4 = 
preds = {uedge: [f1,f2,f4]}


edge labels (req: From, To, Label): uedge(From, To, Label, _)
  optional: LabelBackground, LabelColor

-->

<!-- TODO: Replace with polymer element once table is supported -->
<link rel="import" href="../../elements/mdl-import.html">

<dom-module id="visualizer-test-vis-graph-settings-mapping">
  <style>
    td.nn {
      font-family: "Roboto Mono";
    }
    tr td ul {
      font-size: 12px;
      line-height: 20px;
    }
  </style>
  <template>
    <h4>Mapping ASP predicates to visualization</h4>
    <p>
      The following table presents the predicates supported by the visualization.<br>
      Options in <i>italics</i> are the default values.<br>
      An <strong>identifier</strong> has to be either an atom, a string, or an integer.
    </p>
    <!--
    TODO: Make minitab element, split by some character to table, for arguments.
          Element attributes: r-wrap="&lsquo;" l-wrap="&rsquo;" splitmarker="\\"
                              styled="false"
    -->
    <div>
      <table class="mdl-data-table mdl-js-data-table mdl-shadow--2dp">
      <thead>
        <tr>
          <th class="mdl-data-table__cell--non-numeric">Predicate</th>
          <th class="mdl-data-table__cell--non-numeric">Arguments</th>
          <th class="mdl-data-table__cell--non-numeric">Example</th>
          <th class="mdl-data-table__cell--non-numeric">Alternative</th>
          <th class="mdl-data-table__cell--non-numeric">Attributes</th>
        </tr>
      </thead>
  <tbody>
    <tr>
      <td class="nn mdl-data-table__cell--non-numeric">node(Id)</td>
      <td class="nn mdl-data-table__cell--non-numeric">&lsquo;Id&rsquo; &ndash; node ID</td>
      <td class="nn mdl-data-table__cell--non-numeric">node(1).</td>
      <td class="nn mdl-data-table__cell--non-numeric">&mdash;</td>
      <td class="nn mdl-data-table__cell--non-numeric">
        <a href="#nodeAttr">nodeAttr/3</a>
      </td>
    </tr>
    <tr>
      <td class="nn mdl-data-table__cell--non-numeric">edge(From, To)</td>
      <td class="nn mdl-data-table__cell--non-numeric">
        &lsquo;From&lsquo; &ndash; node identifier<br>
        &lsquo;To&lsquo; &ndash; node identifier<br>
        The identifier of the edge will be set to<br>
        <code>Id = string_concat(From, "%", To);</code><br>
        If the network is undirected,<br>
        &lsquo;From&rsquo; and &lsquo;To&rsquo;<br>
        have no special meaning.
      </td>
      <td class="nn mdl-data-table__cell--non-numeric">edge(1,2).</td>
      <td class="nn mdl-data-table__cell--non-numeric">edge/3</td>
      <td class="nn mdl-data-table__cell--non-numeric">
        <a href="#edgeAttr">edgeAttr/4</a>
      </td>
    </tr>
    <tr>
      <td class="nn mdl-data-table__cell--non-numeric">edge(Id, From, To)</td>
      <td class="nn mdl-data-table__cell--non-numeric">
        &lsquo;Id&lsquo; &ndash; edge identifier<br>
        Otherwise like above, in edge/2.
      </td>
      <td class="nn mdl-data-table__cell--non-numeric">edge(1,1,2).</td>
      <td class="nn mdl-data-table__cell--non-numeric">edge/2</td>
      <td class="nn mdl-data-table__cell--non-numeric">
        <a href="#edgeAttr">edgeAttr/3</a>
      </td>
    </tr>

    <tr>
      <td class="nn mdl-data-table__cell--non-numeric">group(Id)</td>
      <td class="nn mdl-data-table__cell--non-numeric">
        &lsquo;Id&rsquo; &ndash; group identifier
      </td>
      <td class="nn mdl-data-table__cell--non-numeric">group(2).</td>
      <td class="nn mdl-data-table__cell--non-numeric">&mdash;</td>
      <td class="nn mdl-data-table__cell--non-numeric">
        Supports all <a href="#nodeAttr">node attributes</a> that<br>
        make sense for groups,<br>
        using groupAttr/3.
      </td>
    </tr>
    <tr>
      <td class="nn mdl-data-table__cell--non-numeric">layout(Style)</td>
      <td class="nn mdl-data-table__cell--non-numeric">
        &lsquo;Style&rsquo; is one of the following atoms
        <ul>
          <li><i>force</i></li>
          <li>hierarchical</li>
        </ul>
      </td>
      <td class="nn mdl-data-table__cell--non-numeric">layout(force).</td>
      <td class="nn mdl-data-table__cell--non-numeric">&mdash;</td>
      <td class="nn mdl-data-table__cell--non-numeric">
        <a href="#layoutAttr">layoutAttr/2</a>
      </td>
    </tr>
    <tr>
      <td class="nn mdl-data-table__cell--non-numeric">cluster</td>
      <td class="nn mdl-data-table__cell--non-numeric">TODO</td>
      <td class="nn mdl-data-table__cell--non-numeric">TODO</td>
      <td class="nn mdl-data-table__cell--non-numeric">&mdash;</td>
      <td class="nn mdl-data-table__cell--non-numeric">TODO</td>
    </tr>

  </tbody>
</table>
    </div>
  </template>
</dom-module>

<script>
  (function () {
    Polymer({
      is: 'visualizer-test-vis-graph-settings-mapping',
      properties: {
        input: { // has the attributes passed to visingo-visualizer-settings
          type: Object
        },
        settings: {
          type: Object
        }
      }

    });
  })();
</script>



<!--
TODO:
Import parser.
Strip all predicates from the json file calls. Parse all predicate names. Only accept outermost predicate, not predicates inside predicates?
Add those to a dropdown, dropdown defaults to -not chosen-.
Mark which ones are required and which ones are optional.
If there is a predicate that has a name that matches predicate we need, automatically
suggest that predicate instead of -not chosen-.
e.g. *handwave*
cycle -> args cycle([_,From,To], [_,From,To], [_,From,To]) -> edge(From,To) [dropdown-or-something]
cycle -> args cycle([_,Cost],[_,Cost],[_,Cost]) -> cost()



color(edge(N1, N2), yellow)
color(node(N1), red)
label(edge(N1, N2), "duh") or label(edge(N1, N2), 2) for costs
so cost(N1, N2, C) -> label(edge(N1, N2), C) syntax sugar

is name different than label on nodes? probably

colorGrp((N1, N2, N3, N4), yellow) colors all nodes and edges between them

cluster()
shape() // node shape

color inheritance (map html names to rgb somehow)
label bg color
label color
label size (maybe not allow, or do? affect node size)

node size

layout



NOTE: we can discard anything that is not relevant? - YES
      for debugging we just show the original unparsed predicates
      so last rule is "predicate" and we just ignore whatever it gives
      as long as it parses correctly


term
  =




// just scratch

in the following create means create if not exists
whenever you see a node, create that node
whenever you see an edge, create the nodes involved, then create the edge
whenever you see a colorEdge, create the nodes involved, then create the edge, then add the color to it

edge: { from:node to:node }
colorNode: { node:node color:color }
colorEdge: { }



//
DECISIONS:
- INTERACTIVE MODE ALLOWS NO MAPPING, ASP PROGRAM MUST
GIVE THE TERMS REQUIRED
- MAP BOTH IDs AND STRINGS TO JS STRINGS

required form:
node(N)
edge(From, To) or edge(Id, From, To)
  - edges in form edge(From, To) will be given Id = String(From+'%'+To)
nodeAttr(N, color, Value)
edgeAttr(From, To, color, Value) or edgeAttr(Id, color, Value)

aliases?
- nodeColor/2 edgeColor/2 edgeColor/3

if Value is a predicate, map it to js Object {} somehow
if Value is a tuple, map it to js Array []

in general also:
if Value is an atom, set str.isAtom = true
if Value is a string, set str.isAtom = false
by patching the string

foo(bar(1, "nah"), (1,yarr(huh(9))))

{ name: "foo",
  args: [{ name: "bar",
           args: [1, "nah"] },
          [1, {name: "yarr",
               args: {name: "huh",
                      args: [9]}}]
        ]
}



//

node
edge
group
layout


// end scratch


// need to get: all nodes that exist ever
// NO can't be. This would make it impossible to do interactive visualization
// We assume (of course) that node IDs are unique during the program

user gives:
node (req: N, can be multiple times): uedge(N, N, _, _)

parse rule
predicate is uedge - then add arguments[(0, 1)] to nodes
f1 =
preds = {uedge: [f1]}
checkmatch = "uedge(" getNode "," getNode "," "," ")"
getNode = bla:(whatever node can be) { if not global.nodes[bla] then global.nodes[bla] = {} }

edge (req: From, To): uedge(From, To, _, _)
preds = {uedge: [f1, f2]}

coloring nodes (req: Node, Color): ucolor(unode(Node), Color)
preds = {uedge: ..., ucolor: [f3]}
checkmatch = "ucolor(unode"
lets assume ucolor(Color, unode(Node))
checkmatch = "ucolor(" ", unode(" "))"

coloring edges (req: From, To, Color): uedge(From, To, _, Color)
f4 =
preds = {uedge: [f1,f2,f4]}


edge labels (req: From, To, Label): uedge(From, To, Label, _)
  optional: LabelBackground, LabelColor


edge - uedge
what could happen...
edge(From, To) - uedge(To, _, From, _)
edge(Id, From, To) - uedge(Id, (node(From),node(To)))

node req: Id
edge req: From, To ; optionally: Id
edgeAttr given: Attr ; req: Value

add predicate: foo / bar / baz / catchAll
then after that
bar = "uedge(" id:id ", (node(" from:id "),node(" to:id ")))"
{ global.edges.push() }

_ maps to predicate as it was defined before, then just ignored


-->

<!-- TODO: Replace MDL/Boostrap with polymer element once table is supported (paper-data-table?) -->
<!--link rel="import" href="../../elements/mdl-import.html"-->
<link rel="import" href="../../bower_components/font-roboto/roboto.html">

<dom-module id="visualizer-test-vis-graph-settings-mapping">
  <style>
/* BEGIN BOOSTRAP COPYPASTA, REPLACE WITH POLYMER TABLES ONCE POSSIBLE */
code {
  padding: 2px 4px;
  font-size: 90%;
  color: #c7254e;
  background-color: #f9f2f4;
  border-radius: 4px;
}
table {
  border-spacing: 0;
  border-collapse: collapse;
}
td,
th {
  padding: 0;
}
table {
  background-color: transparent;
}
caption {
  padding-top: 8px;
  padding-bottom: 8px;
  color: #777;
  text-align: left;
}
th {
  text-align: left;
}
.table {
  width: 100%;
  max-width: 100%;
  margin-bottom: 20px;
}
.table > thead > tr > th,
.table > tbody > tr > th,
.table > tfoot > tr > th,
.table > thead > tr > td,
.table > tbody > tr > td,
.table > tfoot > tr > td {
  padding: 8px;
  line-height: 1.42857143;
  vertical-align: top;
  border-top: 1px solid #ddd;
}
.table > thead > tr > th {
  vertical-align: bottom;
  border-bottom: 2px solid #ddd;
}
.table > caption + thead > tr:first-child > th,
.table > colgroup + thead > tr:first-child > th,
.table > thead:first-child > tr:first-child > th,
.table > caption + thead > tr:first-child > td,
.table > colgroup + thead > tr:first-child > td,
.table > thead:first-child > tr:first-child > td {
  border-top: 0;
}
.table > tbody + tbody {
  border-top: 2px solid #ddd;
}
.table .table {
  background-color: #fff;
}
.table-condensed > thead > tr > th,
.table-condensed > tbody > tr > th,
.table-condensed > tfoot > tr > th,
.table-condensed > thead > tr > td,
.table-condensed > tbody > tr > td,
.table-condensed > tfoot > tr > td {
  padding: 5px;
}
.table-bordered {
  border: 1px solid #ddd;
}
.table-bordered > thead > tr > th,
.table-bordered > tbody > tr > th,
.table-bordered > tfoot > tr > th,
.table-bordered > thead > tr > td,
.table-bordered > tbody > tr > td,
.table-bordered > tfoot > tr > td {
  border: 1px solid #ddd;
}
.table-bordered > thead > tr > th,
.table-bordered > thead > tr > td {
  border-bottom-width: 2px;
}
.table-striped > tbody > tr:nth-of-type(odd) {
  background-color: #f9f9f9;
}
.table-hover > tbody > tr:hover {
  background-color: #f5f5f5;
}
table col[class*="col-"] {
  position: static;
  display: table-column;
  float: none;
}
table td[class*="col-"],
table th[class*="col-"] {
  position: static;
  display: table-cell;
  float: none;
}
.table > thead > tr > td.active,
.table > tbody > tr > td.active,
.table > tfoot > tr > td.active,
.table > thead > tr > th.active,
.table > tbody > tr > th.active,
.table > tfoot > tr > th.active,
.table > thead > tr.active > td,
.table > tbody > tr.active > td,
.table > tfoot > tr.active > td,
.table > thead > tr.active > th,
.table > tbody > tr.active > th,
.table > tfoot > tr.active > th {
  background-color: #f5f5f5;
}
.table-hover > tbody > tr > td.active:hover,
.table-hover > tbody > tr > th.active:hover,
.table-hover > tbody > tr.active:hover > td,
.table-hover > tbody > tr:hover > .active,
.table-hover > tbody > tr.active:hover > th {
  background-color: #e8e8e8;
}
.table > thead > tr > td.success,
.table > tbody > tr > td.success,
.table > tfoot > tr > td.success,
.table > thead > tr > th.success,
.table > tbody > tr > th.success,
.table > tfoot > tr > th.success,
.table > thead > tr.success > td,
.table > tbody > tr.success > td,
.table > tfoot > tr.success > td,
.table > thead > tr.success > th,
.table > tbody > tr.success > th,
.table > tfoot > tr.success > th {
  background-color: #dff0d8;
}
.table-hover > tbody > tr > td.success:hover,
.table-hover > tbody > tr > th.success:hover,
.table-hover > tbody > tr.success:hover > td,
.table-hover > tbody > tr:hover > .success,
.table-hover > tbody > tr.success:hover > th {
  background-color: #d0e9c6;
}
.table > thead > tr > td.info,
.table > tbody > tr > td.info,
.table > tfoot > tr > td.info,
.table > thead > tr > th.info,
.table > tbody > tr > th.info,
.table > tfoot > tr > th.info,
.table > thead > tr.info > td,
.table > tbody > tr.info > td,
.table > tfoot > tr.info > td,
.table > thead > tr.info > th,
.table > tbody > tr.info > th,
.table > tfoot > tr.info > th {
  background-color: #d9edf7;
}
.table-hover > tbody > tr > td.info:hover,
.table-hover > tbody > tr > th.info:hover,
.table-hover > tbody > tr.info:hover > td,
.table-hover > tbody > tr:hover > .info,
.table-hover > tbody > tr.info:hover > th {
  background-color: #c4e3f3;
}
.table > thead > tr > td.warning,
.table > tbody > tr > td.warning,
.table > tfoot > tr > td.warning,
.table > thead > tr > th.warning,
.table > tbody > tr > th.warning,
.table > tfoot > tr > th.warning,
.table > thead > tr.warning > td,
.table > tbody > tr.warning > td,
.table > tfoot > tr.warning > td,
.table > thead > tr.warning > th,
.table > tbody > tr.warning > th,
.table > tfoot > tr.warning > th {
  background-color: #fcf8e3;
}
.table-hover > tbody > tr > td.warning:hover,
.table-hover > tbody > tr > th.warning:hover,
.table-hover > tbody > tr.warning:hover > td,
.table-hover > tbody > tr:hover > .warning,
.table-hover > tbody > tr.warning:hover > th {
  background-color: #faf2cc;
}
.table > thead > tr > td.danger,
.table > tbody > tr > td.danger,
.table > tfoot > tr > td.danger,
.table > thead > tr > th.danger,
.table > tbody > tr > th.danger,
.table > tfoot > tr > th.danger,
.table > thead > tr.danger > td,
.table > tbody > tr.danger > td,
.table > tfoot > tr.danger > td,
.table > thead > tr.danger > th,
.table > tbody > tr.danger > th,
.table > tfoot > tr.danger > th {
  background-color: #f2dede;
}
.table-hover > tbody > tr > td.danger:hover,
.table-hover > tbody > tr > th.danger:hover,
.table-hover > tbody > tr.danger:hover > td,
.table-hover > tbody > tr:hover > .danger,
.table-hover > tbody > tr.danger:hover > th {
  background-color: #ebcccc;
}
.table-responsive {
  min-height: .01%;
  overflow-x: auto;
}
@media screen and (max-width: 767px) {
  .table-responsive {
    width: 100%;
    margin-bottom: 15px;
    overflow-y: hidden;
    -ms-overflow-style: -ms-autohiding-scrollbar;
    border: 1px solid #ddd;
  }
  .table-responsive > .table {
    margin-bottom: 0;
  }
  .table-responsive > .table > thead > tr > th,
  .table-responsive > .table > tbody > tr > th,
  .table-responsive > .table > tfoot > tr > th,
  .table-responsive > .table > thead > tr > td,
  .table-responsive > .table > tbody > tr > td,
  .table-responsive > .table > tfoot > tr > td {
    white-space: nowrap;
  }
  .table-responsive > .table-bordered {
    border: 0;
  }
  .table-responsive > .table-bordered > thead > tr > th:first-child,
  .table-responsive > .table-bordered > tbody > tr > th:first-child,
  .table-responsive > .table-bordered > tfoot > tr > th:first-child,
  .table-responsive > .table-bordered > thead > tr > td:first-child,
  .table-responsive > .table-bordered > tbody > tr > td:first-child,
  .table-responsive > .table-bordered > tfoot > tr > td:first-child {
    border-left: 0;
  }
  .table-responsive > .table-bordered > thead > tr > th:last-child,
  .table-responsive > .table-bordered > tbody > tr > th:last-child,
  .table-responsive > .table-bordered > tfoot > tr > th:last-child,
  .table-responsive > .table-bordered > thead > tr > td:last-child,
  .table-responsive > .table-bordered > tbody > tr > td:last-child,
  .table-responsive > .table-bordered > tfoot > tr > td:last-child {
    border-right: 0;
  }
  .table-responsive > .table-bordered > tbody > tr:last-child > th,
  .table-responsive > .table-bordered > tfoot > tr:last-child > th,
  .table-responsive > .table-bordered > tbody > tr:last-child > td,
  .table-responsive > .table-bordered > tfoot > tr:last-child > td {
    border-bottom: 0;
  }
}
/* END BOOTSTRAP COPYPASTA */

    tbody td {
      font-family: "Roboto Mono";
      font-size: 14px;
    }
    td.nowrap {
      white-space: nowrap;
    }
    tr.sub {
      /*border-left: 6px solid #909090;*/
      border-left: 5px solid rgba(0,0,0,.22);
    }
    tr td ul {
      font-size: 12px;
      line-height: 20px;
    }

    span.id:before {
      content: "\2018";
    }
    span.id:after {
      content: "\2019";
    }
    span.id {
      font-weight: 700;
    }

  </style>
  <template>
    <h4>Mapping ASP predicates to visualization</h4>
    <p>
      The following two tables present the predicates supported by the visualization.<br>
      Options in <i>italics</i> are the default values.<br>
      An <strong>identifier</strong> has to be either an atom, a string, or an integer. The indentifier has to be unique and non-changing (identifier can't change between answer sets).
    </p>
    <!--
    TODO: Make minitab element, split by some character to table, for arguments.
          Element attributes: r-wrap="&lsquo;" l-wrap="&rsquo;" splitmarker="\\"
                              styled="false"
    -->

    <h5>Entities</h5>
    <div class="tableWrap">
    <table class="table table-bordered table-hover">
      <thead>
        <tr>
          <th>Predicate</th>
          <th>Arguments</th>
          <th>Example</th>
          <th>Alternative</th>
          <th>Attributes</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td class="nowrap">node(Id)</td>
          <td><span class="id">Id</span> &ndash; node identifier</td>
          <td>node(1).</td>
          <td>&mdash;</td>
          <td>
            <a href="#nodeAttr">nodeAttr/3</a>
          </td>
        </tr>
        <tr>
          <td class="nowrap">edge(From, To)</td>
          <td>
            <table>
              <tr>
                <td><span class="id">From</span></td>
                <td>&ndash; node identifier</td>
              </tr>
              <tr>
                <td><span class="id">To</span></td>
                <td>&ndash; node identifier</td>
              </tr>
            </table>
            The identifier of the edge will be set to<br>
            <code>Id = string_concat(From, "%", To);</code><br>
            If the network is undirected,<br>
            <span class="id">From</span> and <span class="id">To</span><br>
            have no special meaning.
          </td>
          <td>edge(1,2).</td>
          <td>edge/3</td>
          <td>
            <a href="#edgeAttr">edgeAttr/4</a>
          </td>
        </tr>
        <tr>
          <td class="nowrap">edge(Id, From, To)</td>
          <td>
            <span class="id">Id</span> &ndash; edge identifier<br>
            Otherwise like above, in edge/2.
          </td>
          <td>edge(1,1,2).</td>
          <td>edge/2</td>
          <td>
            <a href="#edgeAttr">edgeAttr/3</a>
          </td>
        </tr>
        <tr>
          <td class="nowrap">group(Id)</td>
          <td>
            <span class="id">Id</span> &ndash; group identifier
          </td>
          <td>group(2).</td>
          <td>&mdash;</td>
          <td>
            Supports all <a href="#nodeAttr">node attributes</a> that<br>
            make sense for groups,<br>
            using groupAttr/3.
          </td>
        </tr>
      </tbody>
    </table>
    </div>

    <h5>Entity attributes: Nodes</h5>
    <p>Node attributes can be set by <code>nodeAttr(Id, AttributePath, Value)</code></p>
    <div class="tableWrap">
    <table class="table table-bordered table-hover">
      <thead>
        <tr>
          <th>Predicate</th>
          <th>Arguments</th>
          <th>Example</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>nodeAttr</td>
          <td>
            TODO
          </td>
          <td>TODO</td>
        </tr>
      </tbody>
    </table>
    </div>

    <h5>Network attributes: Layout &ndash; Control the layout of the network</h5>
    <p></p>
    <div class="tableWrap">
    <table class="table table-bordered table-hover">
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Default</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
         <td class="nowrap">layout(randomSeed, Value)</td>
          <td>Number</td>
          <td><i>random</i></td>
          <td>
            When using force layout, control the node positioning random seed.
          </td>
        </tr>
        <tr>
         <td class="nowrap">layout(hierarchical, enabled, Value)</td>
          <td>Boolean</td>
          <td>false</td>
          <td>
            Enable hierarchical (tree) layout.
          </td>
        </tr>
        <tr>
         <td class="nowrap">layout(hierarchical, levelSeparation, Value)</td>
          <td>Number</td>
          <td>150</td>
          <td>
            The distance between the different levels.
          </td>
        </tr>
        <tr>
         <td class="nowrap">layout(hierarchical, direction, Value)</td>
          <td>String</td>
          <td>"UD"</td>
          <td>
            The direction of the hierarchical layout. The available options are: UD (up-down), DU (down-up), LR (left-right), RL (right-left).
          </td>
        </tr>
        <tr>
         <td class="nowrap">layout(hierarchical, sortMethod, Value)</td>
          <td>Atom</td>
          <td>hubsize</td>
          <td>
            The algorithm used to ascertain the levels of the nodes based on the data. The possible options are: hubsize, directed.
Hubsize takes the nodes with the most edges and puts them at the top. From that the rest of the hierarchy is evaluated.
Directed adheres to the to and from data of the edges. edge(From,To) so To is a level lower than From.
          </td>
        </tr>
      </tbody>
    </table>
    </div>
  </template>
</dom-module>

<script>
  (function () {
    Polymer({
      is: 'visualizer-test-vis-graph-settings-mapping',
      properties: {
        input: { // has the attributes passed to visingo-visualizer-settings
          type: Object
        },
        settings: {
          type: Object
        }
      }

    });
  })();
</script>
